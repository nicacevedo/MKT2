trControl = trainControl("cv", number=5),
preProcess = c("center","scale"),
tuneLength = 10
)
print(train.knn)
ggplot(train.knn)
test.knn  <- predict(train.knn, newdata=test)
error.knn <- test$Rating-test.knn
print(paste('Error de predicción: ', mean(abs(error.knn))))
# 6. ML --> Random forest
train.randomf <- train(Rating ~ `Unit price`+ Branch + Gender + Semana,
data=train, method="rf",
trControl = trainControl("cv", number=5),
preProcess = c("center","scale"),
tuneLength = 5
)
print(train.randomf)
ggplot(train.randomf)
test.randomf  <- predict(train.randomf, newdata=test)
error.randomf <- test$Rating-test.randomf
print(paste('Error de predicción: ', mean(abs(error.randomf))))
#Modelo de aprendizaje de máquinas
#5. ML --> KNN
train.knn <- train(Rating ~
Branch * `Customer type` * Month  +
Gender  * Payment * `Product line` +
Hour + Day + Week +
`Unit price`*Quantity, #Fórmula
data=train, method="knn",
trControl = trainControl("cv", number=5),
preProcess = c("center","scale"),
tuneLength = 10
)
print(train.knn)
ggplot(train.knn)
test.knn  <- predict(train.knn, newdata=test)
error.knn <- test$Rating-test.knn
print(paste('Error de predicción: ', mean(abs(error.knn))))
# Min-Max:
df.knn <- data.frame(df)
head(df.knn)
# Min-Max:
min.max <- function(column){
max <- max(column)
min <- min(column)
norm.column <- column-min/(max-min)
norm.column
}
# Copia del df
df.knn <- data.frame(df)
# Unit Price
df.knn$Unit.price <- min.max(df$`Unit price`)
# Quantity
df.knn$Quantity <- min.max(df$Quantity)
head(df.knn)
View(df.knn)
View(df.knn)
View(df)
View(df)
# Min-Max:
min.max <- function(column){
max <- max(column)
min <- min(column)
norm.column <- (column-min)/(max-min)
return(norm.column)
}
# Copia del df
df.knn <- data.frame(df)
# Unit Price
df.knn$Unit.price <- min.max(df$`Unit price`)
# Quantity
df.knn$Quantity <- min.max(df$Quantity)
head(df.knn)
# Min-Max:
min.max <- function(column){
max <- max(column)
min <- min(column)
norm.column <- (column-min)/(max-min)
return(norm.column)
}
# Copia de train y test
train.knn <- data.frame(train)
test.knn  <- data.frame(test)
# Unit Price
train.knn$Unit.price <- min.max(train$`Unit price`)
test.knn$Unit.price  <- min.max(test$`Unit price`)
# Quantity
train.knn$Quantity <- min.max(train$Quantity)
test.knn$Quantity  <- min.max(test$Quantity)
# Rating
train.knn$Rating <- min.max(train$Rating)
test.knn$Rating  <- min.max(test$Rating)
head(train.knn)
#Modelo de aprendizaje de máquinas
#5. ML --> KNN
train.knn.prediction <- train(Rating ~
Branch * Customer.type* Month  +
Gender  * Payment * Product.line +
Hour + Day + Week +
Unit.price*Quantity, #Fórmula
data=train.knn,
method="knn",
trControl = trainControl("cv", number=5),
preProcess = c("center","scale"),
tuneLength = 10
)
print(train.knn.prediction)
ggplot(train.knn.prediction)
test.knn.prediction  <- predict(train.knn.prediction, newdata=test.knn)
error.knn <- test.knn$Rating-test.knn.prediction
print(paste('Error de predicción: ', mean(abs(error.knn))))
# Min-Max:
min.max <- function(column){
max <- max(column)
min <- min(column)
norm.column <- (column-min)/(max-min)
return(norm.column)
}
# Copia de train y test
train.knn <- data.frame(train)
test.knn  <- data.frame(test)
# Unit Price
train.knn$Unit.price <- min.max(train$`Unit price`)
test.knn$Unit.price  <- min.max(test$`Unit price`)
# Quantity
train.knn$Quantity <- min.max(train$Quantity)
test.knn$Quantity  <- min.max(test$Quantity)
# Rating
#train.knn$Rating <- min.max(train$Rating)
#test.knn$Rating  <- min.max(test$Rating)
head(train.knn)
#Modelo de aprendizaje de máquinas
#5. ML --> KNN
train.knn.prediction <- train(Rating ~
Branch * Customer.type* Month  +
Gender  * Payment * Product.line +
Hour + Day + Week +
Unit.price*Quantity, #Fórmula
data=train.knn,
method="knn",
trControl = trainControl("cv", number=5),
preProcess = c("center","scale"),
tuneLength = 10
)
print(train.knn.prediction)
ggplot(train.knn.prediction)
test.knn.prediction  <- predict(train.knn.prediction, newdata=test.knn)
error.knn <- test.knn$Rating-test.knn.prediction
print(paste('Error de predicción: ', mean(abs(error.knn))))
#Modelo de aprendizaje de máquinas
#5. ML --> KNN
train.knn.prediction <- train(Rating ~
Branch * Customer.type* Month  +
Gender  * Payment * Product.line +
Hour + Day + Week +
Unit.price*Quantity, #Fórmula
data=train.knn,
method="knn",
trControl = trainControl("cv", number=5),
preProcess = c("center","scale"),
tuneLength = 10
)
print(train.knn.prediction)
ggplot(train.knn.prediction)
test.knn.prediction  <- predict(train.knn.prediction, newdata=test.knn)
error.knn <- test.knn$Rating-test.knn.prediction
print(paste('Error de predicción: ', mean(abs(error.knn))))
# 6. ML --> Random forest
train.randomf <- train(Rating ~
Branch * Customer.type* Month  +
Gender  * Payment * Product.line +
Hour + Day + Week +
Unit.price*Quantity, #Fórmula
data=train, method="rf",
trControl = trainControl("cv", number=5),
preProcess = c("center","scale"),
tuneLength = 5
)
# 6. ML --> Random forest
train.randomf <- train(Rating ~
Branch * `Customer type` * Month  +
Gender  * Payment * `Product line` +
Hour + Day + Week +
`Unit price`*Quantity, #Fórmula
data=train, method="rf",
trControl = trainControl("cv", number=5),
preProcess = c("center","scale"),
tuneLength = 5
)
print(train.randomf)
ggplot(train.randomf)
test.randomf  <- predict(train.randomf, newdata=test)
error.randomf <- test$Rating-test.randomf
print(paste('Error de predicción: ', mean(abs(error.randomf))))
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())   # Limpiamos todos los objetos creados en R. la función ls() indica los nombres de todos los objetos y rm() los remueve.
graphics.off() # Limpiamos los gráficos en el ambiente Plots (esquina inferior derecha)
set.seed(12345) #Fijamos una semilla de aleatoriedad. Se debe realizar si se toman muestras aleatorias o se generan datos aleatorios.
# Cargamos librerias útiles
library(dplyr)
library(knitr)
library(readr)
library(lubridate)
library(ggplot2)
library(lattice)
library(caret)
# Cargar Bases de Datos
supermarket_sales <- read_csv("./supermarket_sales.csv")
df <- supermarket_sales
#transformar a categoricas
df$Branch = as.factor(df$Branch)
df$City = as.factor(df$City)
df$`Customer type`= as.factor(df$`Customer type`)
df$Gender =as.factor(df$Gender)
df$`Product line` = as.factor(df$`Product line`)
df$Payment = as.factor(df$Payment)
#Pasar Date a tipo fecha
df$Date = as.Date(df$Date, tryFormats = c("%m/%d/%Y"))
# Obtenemos las horas de cada Time
df$Hour <- as.numeric(hour(df$Time))
# Obtenemos cada mes (como factor)
df$Month <- as.factor(month(df$Date))
# Agregamos el día de la semana (ordenados)
df$Day <- factor(weekdays(df$Date), levels = c("Monday",
"Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"))
# Fracciones del día en mañana/almuerzo/tarde/noche
df$Frac_Day = as.factor(ifelse(df$Hour <= 11,1, ifelse(df$Hour<=15,2,ifelse(df$Hour<=17,3,4))))
########################
# Intervalos Temporales
########################
# Devolvemos a factor las horas
df$Hour <- as.factor(hour(df$Time))
# Creamos semanas de 7 días
df$Week <- as.factor(ceiling(day(df$Date)/7))
df[df$Week == 5,'Week'] <- '4'
# clasificamos por semana c/fecha
df$Semana <- cut(df$Date, breaks = "1 week", labels = FALSE)
df$Semana = as.factor(df$Semana)
df <- df[with(df, order(df$Date)), ]
# Agregamos hora del día (mañana, tarde, noche)
#Divsion de los datos
# samples aleatorio
index <- sample(1:nrow(df), size= nrow(df)*0.8)
# entrenamiento 80%
train <- df[index, ]
# test 20%
test  <- df[-index, ]
#Regresiones regulares
#0. Regresion lineal sin diferenciar por tienda
train.lm <- train(form = Rating ~ Branch + `Customer type` + Gender + `Product line` + `Unit price` + + Quantity + `Unit price`*Quantity + Payment + Month + Day + Hour, #Fórmula
data = train, #Datos
method = "lm", #Algoritmo
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
test.lm  <- predict(train.lm , newdata=test) #Vector de datos predichos. Recibe una base de datos (newdata) y un modelo entrenado (train.lm)
error.lm <- test$Rating-test.lm #Calcular los errores de predicción (dato real - dato estimado)
summary(train.lm)
print(paste('Error de predicción: ', mean(abs(error.lm))))
#Regresiones con intervalos
#0.2 Regresion lineal con intervalos temporales
train.lm <- train(form = Rating ~ Branch + `Customer type` + Gender + `Product line` + `Unit price` + Quantity + `Unit price`*Quantity + Payment + Month + Week + Day + Hour, #Fórmula
data = train, #Datos
method = "lm", #Algoritmo
na.action = na.pass, # Ignorar NA
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
test.lm  <- predict(train.lm , newdata=test) #Vector de datos predichos. Recibe una base de datos (newdata) y un modelo entrenado (train.lm)
error.lm <- test$Rating-test.lm #Calcular los errores de predicción (dato real - dato estimado)
summary(train.lm)
print(paste('Error de predicción: ', mean(abs(error.lm))))
#Regresiones con intervalos
#0.2 Regresion lineal con intervalos temporales
train.lm <- train(form = Rating ~
Branch * `Customer type` * Month  +
Gender  * Payment * `Product line` +
`Unit price`+ Quantity +
Hour + Day + Week, #Fórmula
data = train, #Datos
method = "lm", #Algoritmo
na.action = na.pass, # Ignorar NA
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
test.lm  <- predict(train.lm , newdata=test) #Vector de datos predichos. Recibe una base de datos (newdata) y un modelo entrenado (train.lm)
error.lm <- test$Rating-test.lm #Calcular los errores de predicción (dato real - dato estimado)
summary(train.lm)
print(paste('Error de predicción: ', mean(abs(error.lm))))
#Regresiones con intervalos
#0.2 Regresion lineal con intervalos temporales
train.lm <- train(form = Rating ~
Branch * `Customer type` * Month  +
Gender  * Payment * `Product line` +
`Unit price`* Quantity +
Hour + Day + Week, #Fórmula
data = train, #Datos
method = "lm", #Algoritmo
na.action = na.pass, # Ignorar NA
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
test.lm  <- predict(train.lm , newdata=test) #Vector de datos predichos. Recibe una base de datos (newdata) y un modelo entrenado (train.lm)
error.lm <- test$Rating-test.lm #Calcular los errores de predicción (dato real - dato estimado)
summary(train.lm)
print(paste('Error de predicción: ', mean(abs(error.lm))))
print(paste('Error de predicción: ', mean(abs(error.lm))))
#Regresiones con intervalos
#0.2 Regresion lineal con intervalos temporales
train.lm <- train(form = Rating ~
Branch * `Customer type` * Month  +
Gender  * Payment * `Product line` +
`Unit price`* Quantity +
Hour + Day + Week, #Fórmula
data = train, #Datos
method = "lm", #Algoritmo
na.action = na.pass, # Ignorar NA
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
test.lm  <- predict(train.lm , newdata=test) #Vector de datos predichos. Recibe una base de datos (newdata) y un modelo entrenado (train.lm)
error.lm <- test$Rating-test.lm #Calcular los errores de predicción (dato real - dato estimado)
summary(train.lm)
print(paste('Error de predicción: ', mean(abs(error.lm))))
print(paste('Error de predicción: ', mean(abs(error.lm))))
#Regresiones con intervalos
#0.2 Regresion lineal con intervalos temporales
train.lm <- train(form = Rating ~
Branch * `Customer type` * Month  +
Gender  * Payment * `Product line` +
`Unit price`+ Quantity +
Hour + Day + Week, #Fórmula
data = train, #Datos
method = "lm", #Algoritmo
na.action = na.pass, # Ignorar NA
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
test.lm  <- predict(train.lm , newdata=test) #Vector de datos predichos. Recibe una base de datos (newdata) y un modelo entrenado (train.lm)
error.lm <- test$Rating-test.lm #Calcular los errores de predicción (dato real - dato estimado)
summary(train.lm)
print(paste('Error de predicción: ', mean(abs(error.lm))))
print(paste('Error de predicción: ', mean(abs(error.lm))))
#2. Regresion lineal diferenciando por tienda
allstores = unique(train$Branch) # Valores únicos de cada tienda
nobs = nrow(train)  # filas del set de training
nbranches = length(allstores) # n de tiendas
atributos_interes <- c('Total','Gender')
#regcoeff = array(NA, dim=c(nbranches,length(atributos_interes))) # matriz auxiliar vacía para los coefs de las 3 tiendas
regcoeff = array(NA, dim=c(nbranches,11))
# Loop en las tiendas
for (i in 1:nbranches){
sub_train <- train[(train$Branch==allstores[i]),]
#regrmodel = lm(Rating2 ~ Uprice + Gender2 + Semana2)
reg_model <- lm(Rating ~Total + `Customer type` + Gender + `Product line` + Payment, data = sub_train)
#print(summary(reg_model))
# print(reg_model$coeff)
#regcoeff[i,] = reg_model$coeff
sub_test <- test[test$Branch==allstores[i],]
reg_model_test.lm  <- predict(reg_model , newdata=sub_test) #Vector de datos predichos. Recibe una base de datos (newdata) y un modelo entrenado (train.lm)
error.lm2 <- (sub_test$Rating -  reg_model_test.lm) #Calcular los errores de predicción (dato real - dato estimado)
summary(reg_model)
print(paste('Branch:', allstores[i],'\tError:',mean(abs(error.lm2))))
}
#2. Regresion lineal diferenciando por tienda
allstores = unique(train$Branch) # Valores únicos de cada tienda
nobs = nrow(train)  # filas del set de training
nbranches = length(allstores) # n de tiendas
atributos_interes <- c('Total','Gender')
#regcoeff = array(NA, dim=c(nbranches,length(atributos_interes))) # matriz auxiliar vacía para los coefs de las 3 tiendas
regcoeff = array(NA, dim=c(nbranches,11))
# Loop en las tiendas
for (i in 1:nbranches){
sub_train <- train[(train$Branch==allstores[i]),]
#regrmodel = lm(Rating2 ~ Uprice + Gender2 + Semana2)
reg_model <- lm(Rating ~
Branch * `Customer type` * Month  +
Gender  * Payment * `Product line` +
`Unit price`+ Quantity +
Hour + Day + Week, #Fórmula,
data = sub_train)
#print(summary(reg_model))
# print(reg_model$coeff)
#regcoeff[i,] = reg_model$coeff
sub_test <- test[test$Branch==allstores[i],]
reg_model_test.lm  <- predict(reg_model , newdata=sub_test) #Vector de datos predichos. Recibe una base de datos (newdata) y un modelo entrenado (train.lm)
error.lm2 <- (sub_test$Rating -  reg_model_test.lm) #Calcular los errores de predicción (dato real - dato estimado)
summary(reg_model)
print(paste('Branch:', allstores[i],'\tError:',mean(abs(error.lm2))))
}
#2. Regresion lineal diferenciando por tienda
allstores = unique(train$Branch) # Valores únicos de cada tienda
nobs = nrow(train)  # filas del set de training
nbranches = length(allstores) # n de tiendas
atributos_interes <- c('Total','Gender')
#regcoeff = array(NA, dim=c(nbranches,length(atributos_interes))) # matriz auxiliar vacía para los coefs de las 3 tiendas
regcoeff = array(NA, dim=c(nbranches,11))
# Loop en las tiendas
for (i in 1:nbranches){
sub_train <- train[(train$Branch==allstores[i]),]
#regrmodel = lm(Rating2 ~ Uprice + Gender2 + Semana2)
reg_model <- lm(Rating ~
`Customer type` * Month  +
Gender  * Payment * `Product line` +
`Unit price`+ Quantity +
Hour + Day + Week, #Fórmula,
data = sub_train)
#print(summary(reg_model))
# print(reg_model$coeff)
#regcoeff[i,] = reg_model$coeff
sub_test <- test[test$Branch==allstores[i],]
reg_model_test.lm  <- predict(reg_model , newdata=sub_test) #Vector de datos predichos. Recibe una base de datos (newdata) y un modelo entrenado (train.lm)
error.lm2 <- (sub_test$Rating -  reg_model_test.lm) #Calcular los errores de predicción (dato real - dato estimado)
summary(reg_model)
print(paste('Branch:', allstores[i],'\tError:',mean(abs(error.lm2))))
}
#Regresión autoselección
# Lasso
train.lasso <- train(form = Rating ~
Branch * `Customer type` * Month  +
Gender  * Payment * `Product line` +
Hour + Day + Week +
`Unit price`*Quantity, #Fórmula
data = train, #Datos
method = "glmnet", #Algoritmo
tuneGrid = expand.grid(alpha = 1, lambda = 1),
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
test.lasso  <- predict(train.lasso , newdata=test) #Vector de datos predichos. Recibe una base de datos (newdata) y un modelo entrenado (train.lm)
error.lasso <- test$Rating-test.lasso #Calcular los errores de predicción (dato real - dato estimado)
print(paste('Error de predicción: ', mean(abs(error.lasso))))
#Regresión autoselección
# Risge
train.rr <- train(form = Rating ~
Branch * `Customer type` * Month  +
Gender  * Payment * `Product line` +
Hour + Day + Week +
`Unit price`*Quantity, #Fórmula
data = train, #Datos
method = "glmnet", #Algoritmo
tuneGrid = expand.grid(alpha = 0, lambda = 1),
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
test.rr <- predict(train.rr , newdata=test) #Vector de datos predichos. Recibe una base de datos (newdata) y un modelo entrenado (train.lm)
error.rr <- test$Rating-test.rr #Calcular los errores de predicción (dato real - dato estimado)
print(paste('Error de predicción: ', mean(abs(error.rr))))
# Min-Max:
min.max <- function(column){
max <- max(column)
min <- min(column)
norm.column <- (column-min)/(max-min)
return(norm.column)
}
# Copia de train y test
train.knn <- data.frame(train)
test.knn  <- data.frame(test)
# Unit Price
train.knn$Unit.price <- min.max(train$`Unit price`)
test.knn$Unit.price  <- min.max(test$`Unit price`)
# Quantity
train.knn$Quantity <- min.max(train$Quantity)
test.knn$Quantity  <- min.max(test$Quantity)
# Rating
#train.knn$Rating <- min.max(train$Rating)
#test.knn$Rating  <- min.max(test$Rating)
head(train.knn)
#Modelo de aprendizaje de máquinas
#5. ML --> KNN
train.knn.prediction <- train(Rating ~
Branch * Customer.type* Month  +
Gender  * Payment * Product.line +
Hour + Day + Week +
Unit.price*Quantity, #Fórmula
data=train.knn,
method="knn",
trControl = trainControl("cv", number=5),
preProcess = c("center","scale"),
tuneLength = 10
)
print(train.knn.prediction)
ggplot(train.knn.prediction)
test.knn.prediction  <- predict(train.knn.prediction, newdata=test.knn)
error.knn <- test.knn$Rating-test.knn.prediction
print(paste('Error de predicción: ', mean(abs(error.knn))))
# 6. ML --> Random forest
train.randomf <- train(Rating ~
Branch * `Customer type` * Month  +
Gender  * Payment * `Product line` +
Hour + Day + Week +
`Unit price`*Quantity, #Fórmula
data=train, method="rf",
trControl = trainControl("cv", number=5),
preProcess = c("center","scale"),
tuneLength = 5
)
print(train.randomf)
ggplot(train.randomf)
test.randomf  <- predict(train.randomf, newdata=test)
error.randomf <- test$Rating-test.randomf
print(paste('Error de predicción: ', mean(abs(error.randomf))))
#Modelo de aprendizaje de máquinas
#5. ML --> KNN
train.knn.prediction <- train(Rating ~
Branch * Customer.type* Month  +
Gender  * Payment * Product.line +
Hour + Day + Week +
Unit.price*Quantity, #Fórmula
data=train.knn,
method="knn",
trControl = trainControl("cv", number=10),
preProcess = c("center","scale"),
tuneLength = 10
)
print(train.knn.prediction)
ggplot(train.knn.prediction)
test.knn.prediction  <- predict(train.knn.prediction, newdata=test.knn)
error.knn <- test.knn$Rating-test.knn.prediction
print(paste('Error de predicción: ', mean(abs(error.knn))))
