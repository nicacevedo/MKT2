train.knn <- train(Rating ~ `Unit price`+ Branch + Gender + Semana,
data=train, method="knn",
trControl = trainControl("cv", number=5),
preProcess = c("center","scale"),
tuneLength = 5
)
print(train.knn)
ggplot(train.knn)
test.knn  <- predict(train.knn, newdata=test)
error.knn <- test$Rating-test.knn
print(paste('Error de predicción: ', mean(abs(error.knn))))
#Modelo de aprendizaje de máquinas
#5. ML --> KNN
train.knn <- train(Rating ~ `Unit price`+ Branch + Gender + Semana,
data=train, method="knn",
trControl = trainControl("cv", number=5),
preProcess = c("center","scale"),
tuneLength = 5
)
print(train.knn)
ggplot(train.knn)
test.knn  <- predict(train.knn, newdata=test)
error.knn <- test$Rating-test.knn
print(paste('Error de predicción: ', mean(abs(error.knn))))
#Modelo de aprendizaje de máquinas
#5. ML --> KNN
train.knn <- train(Rating ~ `Unit price`+ Branch + Gender + Semana,
data=train, method="knn",
trControl = trainControl("cv", number=5),
preProcess = c("center","scale"),
tuneLength = 10
)
print(train.knn)
ggplot(train.knn)
test.knn  <- predict(train.knn, newdata=test)
error.knn <- test$Rating-test.knn
print(paste('Error de predicción: ', mean(abs(error.knn))))
#Modelo de aprendizaje de máquinas
#5. ML --> KNN
train.knn <- train(Rating ~ `Unit price`+ Branch + Gender + Semana,
data=train, method="knn",
trControl = trainControl("cv", number=5),
preProcess = c("center","scale"),
tuneLength = 20
)
print(train.knn)
ggplot(train.knn)
test.knn  <- predict(train.knn, newdata=test)
error.knn <- test$Rating-test.knn
print(paste('Error de predicción: ', mean(abs(error.knn))))
#Modelo de aprendizaje de máquinas
#5. ML --> KNN
train.knn <- train(Rating ~ `Unit price`+ Branch + Gender + Semana,
data=train, method="knn",
trControl = trainControl("cv", number=5),
preProcess = c("center","scale"),
tuneLength = 10
)
print(train.knn)
ggplot(train.knn)
test.knn  <- predict(train.knn, newdata=test)
error.knn <- test$Rating-test.knn
print(paste('Error de predicción: ', mean(abs(error.knn))))
# 6. ML --> Random forest
train.randomf <- train(Rating ~ `Unit price`+ Branch + Gender + Semana,
data=train, method="rf",
trControl = trainControl("cv", number=5),
preProcess = c("center","scale"),
tuneLength = 5
)
print(train.randomf)
ggplot(train.randomf)
test.randomf  <- predict(train.randomf, newdata=test)
error.randomf <- test$Rating-test.randomf
print(paste('Error de predicción: ', mean(abs(error.randomf))))
#Modelo Homogéneo con variables explicativas
df$Satisfecho <- df$Rating >= 7
head(df)
#Modelo Homogéneo con variables explicativas
df$Satisfecho <- as.numeric(df$Rating >= 7)
head(df)
#Modelo Homogéneo con variables explicativas
df$Satisfecho <- as.numeric(df$Rating >= 7)
head(df)
head(test)
#Modelo Homogéneo con variables explicativas
train$Satisfecho <- as.numeric(train$Rating >= 7)
test$Satisfecho <- as.numeric(test$Rating >= 7)
head(test)
#Regresiones regulares
#0. Regresion lineal sin diferenciar por tienda
train.lm <- train(form = Satisfecho ~ Total + Branch + `Customer type` + Gender + `Product line` + Payment + Day, #Fórmula
data = train, #Datos
method = "lm", #Algoritmo
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
test.lm  <- predict(train.lm , newdata=test) #Vector de datos predichos. Recibe una base de datos (newdata) y un modelo entrenado (train.lm)
error.lm <- test$Rating-test.lm #Calcular los errores de predicción (dato real - dato estimado)
#Modelo Homogéneo con variables explicativas
train$Satisfecho <- as.factor(train$Rating >= 7)
test$Satisfecho <- as.factor(test$Rating >= 7)
head(test)
#Regresiones regulares
#0. Regresion lineal sin diferenciar por tienda
train.lm <- train(form = Satisfecho ~ Total + Branch + `Customer type` + Gender + `Product line` + Payment + Day, #Fórmula
data = train, #Datos
method = "lm", #Algoritmo
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
#Regresión autoselección
# Lasso
train.lasso <- train(form = Rating ~ Day + Quantity + `Unit price`, #Fórmula
data = train, #Datos
method = "glmnet", #Algoritmo
family = 'binomial'
#tuneGrid = expand.grid(alpha = 1, lambda = 1),
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
#Regresión autoselección
# Lasso
train.lasso <- train(form = Rating ~ Day + Quantity + `Unit price`, #Fórmula
data = train, #Datos
method = "glmnet", #Algoritmo
family = 'binomial',
#tuneGrid = expand.grid(alpha = 1, lambda = 1),
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
#Regresión autoselección
# Lasso
train.lasso <- train(form = Rating ~ Day + Quantity + `Unit price`, #Fórmula
data = train, #Datos
method = "multinom", #Algoritmo
family = 'binomial',
#tuneGrid = expand.grid(alpha = 1, lambda = 1),
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
#Regresión autoselección
# Lasso
train.lasso <- train(form = Rating ~ Day + Quantity + `Unit price`, #Fórmula
data = train, #Datos
method = "glmnet", #Algoritmo
family = 'multinom',
#tuneGrid = expand.grid(alpha = 1, lambda = 1),
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
#Regresión autoselección
# Lasso
train.lasso <- train(form = Rating ~ Day + Quantity + `Unit price`, #Fórmula
data = train, #Datos
method = "mulitnom", #Algoritmo
#family = 'multinom',
#tuneGrid = expand.grid(alpha = 1, lambda = 1),
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
#Regresión autoselección
# Lasso
train.lasso <- train(form = Rating ~ Day + Quantity + `Unit price`, #Fórmula
data = train, #Datos
method = "multinom", #Algoritmo
#family = 'multinom',
#tuneGrid = expand.grid(alpha = 1, lambda = 1),
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
#Regresión autoselección
# Lasso
train.lasso <- train(form = Satisfecho ~ Day + Quantity + `Unit price`, #Fórmula
data = train, #Datos
method = "multinom", #Algoritmo
#family = 'multinom',
#tuneGrid = expand.grid(alpha = 1, lambda = 1),
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
#Regresión autoselección
# Lasso
train.lasso <- train(form = Satisfecho ~ Day + Quantity + `Unit price`, #Fórmula
data = train, #Datos
method = "glmnet", #Algoritmo
family = 'binom',
#tuneGrid = expand.grid(alpha = 1, lambda = 1),
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
#Regresión autoselección
# Lasso
train.lasso <- train(form = Satisfecho ~ Day + Quantity + `Unit price`, #Fórmula
data = train, #Datos
method = "glmnet", #Algoritmo
family = 'binom',
#tuneGrid = expand.grid(alpha = 1, lambda = 1),
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
install.packages('e1071')
#Regresión autoselección
# Lasso
train.lasso <- train(form = Satisfecho ~ Day + Quantity + `Unit price`, #Fórmula
data = train, #Datos
method = "glmnet", #Algoritmo
family = 'binom',
#tuneGrid = expand.grid(alpha = 1, lambda = 1),
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
test.lasso  <- predict(train.lasso , newdata=test) #Vector de datos predichos. Recibe una base de datos (newdata) y un modelo entrenado (train.lm)
error.lasso <- test$Rating-test.lasso #Calcular los errores de predicción (dato real - dato estimado)
print(paste('Error de predicción: ', mean(abs(error.lasso))))
#Regresión autoselección
# Lasso
train.lasso <- train(form = Satisfecho ~ Day + Quantity + `Unit price`, #Fórmula
data = train, #Datos
method = "mulitnom", #Algoritmo
#family = 'binom',
#tuneGrid = expand.grid(alpha = 1, lambda = 1),
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
#Regresión autoselección
# Lasso
train.lasso <- train(form = Satisfecho ~ Day + Quantity + `Unit price`, #Fórmula
data = train, #Datos
method = "multinom", #Algoritmo
#family = 'binom',
#tuneGrid = expand.grid(alpha = 1, lambda = 1),
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
test.lasso  <- predict(train.lasso , newdata=test) #Vector de datos predichos. Recibe una base de datos (newdata) y un modelo entrenado (train.lm)
error.lasso <- test$Rating-test.lasso #Calcular los errores de predicción (dato real - dato estimado)
print(paste('Error de predicción: ', mean(abs(error.lasso))))
#Regresión autoselección
# Lasso
train.lasso <- train(form = Satisfecho ~ Day + Quantity + `Unit price`, #Fórmula
data = train, #Datos
method = "glmnet", #Algoritmo
family = 'binom',
#tuneGrid = expand.grid(alpha = 1, lambda = 1),
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
test.lasso  <- predict(train.lasso , newdata=test) #Vector de datos predichos. Recibe una base de datos (newdata) y un modelo entrenado (train.lm)
error.lasso <- test$Rating-test.lasso #Calcular los errores de predicción (dato real - dato estimado)
print(paste('Error de predicción: ', mean(abs(error.lasso))))
#Regresión autoselección
# Lasso
train.lasso <- train(form = Satisfecho ~ Total +  Day + Quantity + `Unit price`, #Fórmula
data = train, #Datos
method = "glmnet", #Algoritmo
family = 'binom',
#tuneGrid = expand.grid(alpha = 1, lambda = 1),
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
test.lasso  <- predict(train.lasso , newdata=test) #Vector de datos predichos. Recibe una base de datos (newdata) y un modelo entrenado (train.lm)
error.lasso <- test$Rating-test.lasso #Calcular los errores de predicción (dato real - dato estimado)
print(paste('Error de predicción: ', mean(abs(error.lasso))))
#Regresión autoselección
# Lasso
train.lasso <- train(form = Satisfecho ~ Total +  Day + Quantity + `Unit price`, #Fórmula
data = train, #Datos
method = "glmnet", #Algoritmo
family = 'binom',
#tuneGrid = expand.grid(alpha = 1, lambda = 1),
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
test.lasso  <- predict(train.lasso , newdata=test) #Vector de datos predichos. Recibe una base de datos (newdata) y un modelo entrenado (train.lm)
error.lasso <- test$Satisfecho-test.lasso #Calcular los errores de predicción (dato real - dato estimado)
print(paste('Error de predicción: ', mean(abs(error.lasso))))
#Regresión autoselección
# Lasso
train.lasso <- train(form = Satisfecho ~  Day + Quantity + `Unit price`, #Fórmula
data = train, #Datos
method = "glmnet", #Algoritmo
family = 'binom',
#tuneGrid = expand.grid(alpha = 1, lambda = 1),
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
test.lasso  <- predict(train.lasso , newdata=test) #Vector de datos predichos. Recibe una base de datos (newdata) y un modelo entrenado (train.lm)
error.lasso <- test$Satisfecho-test.lasso #Calcular los errores de predicción (dato real - dato estimado)
print(paste('Error de predicción: ', mean(abs(error.lasso))))
#Regresión autoselección
# Lasso
train.lasso <- train(form = Satisfecho ~  Day + Quantity + `Unit price`, #Fórmula
data = train, #Datos
method = "glmnet", #Algoritmo
family = 'binom',
#tuneGrid = expand.grid(alpha = 1, lambda = 1),
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
test.lasso  <- predict(train.lasso , newdata=test) #Vector de datos predichos. Recibe una base de datos (newdata) y un modelo entrenado (train.lm)
error.lasso <- test$Satisfecho-test.lasso #Calcular los errores de predicción (dato real - dato estimado)
print(test.lasso)
print(paste('Error de predicción: ', mean(abs(error.lasso))))
#Regresión autoselección
# Lasso
train.lasso <- train(form = Satisfecho ~  Day + Quantity + `Unit price`, #Fórmula
data = train, #Datos
method = "glmnet", #Algoritmo
family = 'binom',
#tuneGrid = expand.grid(alpha = 1, lambda = 1),
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
test.lasso  <- predict(train.lasso , newdata=test) #Vector de datos predichos. Recibe una base de datos (newdata) y un modelo entrenado (train.lm)
error.lasso <- test$Satisfecho-as.numeric(test.lasso) #Calcular los errores de predicción (dato real - dato estimado)
#print(error.lasso)
print(paste('Error de predicción: ', mean(abs(error.lasso))))
#Regresión autoselección
# Lasso
train.lasso <- train(form = Satisfecho ~  Day + Quantity + `Unit price`, #Fórmula
data = train, #Datos
method = "glmnet", #Algoritmo
family = 'binom',
#tuneGrid = expand.grid(alpha = 1, lambda = 1),
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
test.lasso  <- predict(train.lasso , newdata=test) #Vector de datos predichos. Recibe una base de datos (newdata) y un modelo entrenado (train.lm)
error.lasso <- as.numeric(test$Satisfecho)-as.numeric(test.lasso) #Calcular los errores de predicción (dato real - dato estimado)
#print(error.lasso)
print(paste('Error de predicción: ', mean(abs(error.lasso))))
457.4430/72.61
6*72.61
6*72.61*(1+0.05)
as.time(df$Time)
as.Time(df$Time)
rm(list=ls())   # Limpiamos todos los objetos creados en R. la función ls() indica los nombres de todos los objetos y rm() los remueve.
graphics.off() # Limpiamos los gráficos en el ambiente Plots (esquina inferior derecha)
set.seed(12345) #Fijamos una semilla de aleatoriedad. Se debe realizar si se toman muestras aleatorias o se generan datos aleatorios.
library(dplyr)
library(knitr) #llamamos a la librería que nos permite visualizar contenido en Rmarkdown
library(readr)
library(lubridate)
library(ggplot2)
library(lattice)
library(caret)
library(Hmisc) # todos los histogramas ??
as.(df$Time)
supermarket_sales <- read_csv("./Tarea1/supermarket_sales.csv")
View(supermarket_sales)
#cambiarle el nombre a la base para que sea mas corto y mas facil de trabajar
df <- supermarket_sales
#transformar a categoricas
df$Branch = as.factor(df$Branch)
df$City =as.factor(df$City)
df$`Customer type`= as.factor(df$`Customer type`)
df$Gender =as.factor(df$Gender)
df$`Product line` = as.factor(df$`Product line`)
df$Payment = as.factor(df$Payment)
#Pasar Date a tipo fecha
df$Date = as.Date(df$Date, tryFormats = c("%m/%d/%Y"))
class(df$Date)
#Nivel de agregacion
#1. clasificamos por semana c/fecha
df$Semana <- cut(df$Date, breaks = "1 week", labels = FALSE)
df$Semana = as.factor(df$Semana)
df <- df[with(df, order(df$Date)), ]
#3. Agregamos el día de la semana
View(df)
38340/60/60
View(df)
View(df)
72.61*6
str(df$`gross margin percentage`)
summary(df$`gross margin percentage`)
knitr::opts_chunk$set(echo = TRUE)
set.seed(12345) #Fijamos una semilla de aleatoriedad. Se debe realizar si se toman muestras aleatorias o se generan datos aleatorios.
# Cargamos librerias útiles
library(dplyr)
library(knitr)
library(readr)
library(lubridate)
library(ggplot2)
library(lattice)
library(caret)
library(Hmisc)
# Cargar Bases de Datos
supermarket_sales <- read_csv("./supermarket_sales.csv")
df <- supermarket_sales
#transformar a categoricas
df$Branch = as.factor(df$Branch)
df$City = as.factor(df$City)
df$`Customer type`= as.factor(df$`Customer type`)
df$Gender =as.factor(df$Gender)
df$`Product line` = as.factor(df$`Product line`)
df$Payment = as.factor(df$Payment)
#Pasar Date a tipo fecha
df$Date = as.Date(df$Date, tryFormats = c("%m/%d/%Y"))
#1. clasificamos por semana c/fecha
df$Semana <- cut(df$Date, breaks = "1 week", labels = FALSE)
df$Semana = as.factor(df$Semana)
df <- df[with(df, order(df$Date)), ]
# Agregamos el día de la semana
df$Day <- as.factor(weekdays(df$Date))
# Agregamos hora del día (mañana, tarde, noche)
#Divsion de los datos
# samples aleatorio
index <- sample(1:nrow(df), size= nrow(df)*0.7)
# entrenamiento 70%
train <- df[index, ]
# test 30%
test  <- df[-index, ]
#Regresiones regulares
#0. Regresion lineal sin diferenciar por tienda
train.lm <- train(form = Rating ~ Branch + `Customer type` + Gender + `Product line` + `Unit price` + + Quantity + Payment + Date + Time, #Fórmula
data = train, #Datos
method = "lm", #Algoritmo
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
test.lm  <- predict(train.lm , newdata=test) #Vector de datos predichos. Recibe una base de datos (newdata) y un modelo entrenado (train.lm)
error.lm <- test$Rating-test.lm #Calcular los errores de predicción (dato real - dato estimado)
summary(train.lm)
print(paste('Error de predicción: ', mean(abs(error.lm))))
hour(df$Time)
summary(hour(df$Time))
df$Hour <- as.factor(hour(df$Time))
# test 30%
test  <- df[-index, ]
#Divsion de los datos
# samples aleatorio
index <- sample(1:nrow(df), size= nrow(df)*0.7)
# entrenamiento 70%
train <- df[index, ]
# test 30%
test  <- df[-index, ]
View(test)
#Regresiones regulares
#0. Regresion lineal sin diferenciar por tienda
train.lm <- train(form = Rating ~ Branch + `Customer type` + Gender + `Product line` + `Unit price` + + Quantity + Payment + Date + Hour, #Fórmula
data = train, #Datos
method = "lm", #Algoritmo
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
test.lm  <- predict(train.lm , newdata=test) #Vector de datos predichos. Recibe una base de datos (newdata) y un modelo entrenado (train.lm)
error.lm <- test$Rating-test.lm #Calcular los errores de predicción (dato real - dato estimado)
summary(train.lm)
print(paste('Error de predicción: ', mean(abs(error.lm))))
Month(df$Date)
month(df$Date)
# Obtenemos cada mes (como factor)
df$Month <- as.factor(month(df$Date))
# Agregamos el día de la semana
df$Day <- as.factor(weekdays(df$Date))
#Divsion de los datos
# samples aleatorio
index <- sample(1:nrow(df), size= nrow(df)*0.7)
# entrenamiento 70%
train <- df[index, ]
# test 30%
test  <- df[-index, ]
#Regresiones regulares
#0. Regresion lineal sin diferenciar por tienda
train.lm <- train(form = Rating ~ Branch + `Customer type` + Gender + `Product line` + `Unit price` + + Quantity + Payment + Month + Day + Hour, #Fórmula
data = train, #Datos
method = "lm", #Algoritmo
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
test.lm  <- predict(train.lm , newdata=test) #Vector de datos predichos. Recibe una base de datos (newdata) y un modelo entrenado (train.lm)
error.lm <- test$Rating-test.lm #Calcular los errores de predicción (dato real - dato estimado)
summary(train.lm)
print(paste('Error de predicción: ', mean(abs(error.lm))))
#Regresiones regulares
#0. Regresion lineal sin diferenciar por tienda
train.lm <- train(form = Rating ~ Branch + `Customer type` + Gender + `Product line` + `Unit price` + + Quantity + `Unit price`*Quantity + Payment + Month + Day + Hour, #Fórmula
data = train, #Datos
method = "lm", #Algoritmo
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
test.lm  <- predict(train.lm , newdata=test) #Vector de datos predichos. Recibe una base de datos (newdata) y un modelo entrenado (train.lm)
error.lm <- test$Rating-test.lm #Calcular los errores de predicción (dato real - dato estimado)
summary(train.lm)
print(paste('Error de predicción: ', mean(abs(error.lm))))
# Fracciones del día en mañana/almuerzo/tarde/noche
df$Frac_Day = as.factor(ifelse(df$Hora <= 11,1, ifelse(df$Hora<=15,2,ifelse(df$Hora<=17,3,4))))
as.factor(ifelse(df$Hora <= 11,1,
ifelse(df$Hora<=15,2,
ifelse(df$Hora<=17,3,4)
)
)
)
# Fracciones del día en mañana/almuerzo/tarde/noche
df$Frac_Day = as.factor(ifelse(df$Hour <= 11,1,
ifelse(df$Hour<=15,2,
ifelse(df$Hour<=17,3,4)
)
)
)
# Obtenemos las horas de cada Time
df$Hour <- as.numeric(hour(df$Time))
df$Frac_Day = as.factor(ifelse(df$Hour <= 11,1,
ifelse(df$Hour<=15,2,
ifelse(df$Hour<=17,3,4)
)
)
)
# Obtenemos las horas de cada Time
df$Hour <- as.factor(hour(df$Time))
#Divsion de los datos
# samples aleatorio
index <- sample(1:nrow(df), size= nrow(df)*0.7)
# entrenamiento 70%
train <- df[index, ]
# test 30%
test  <- df[-index, ]
#Regresiones con intervalos
#0.2 Regresion lineal con intervalos
train.lm <- train(form = Rating ~ Branch + `Customer type` + Gender + `Product line` + `Unit price` + + Quantity + `Unit price`*Quantity + Payment + Month + Day + Frac_Hour, #Fórmula
data = train, #Datos
method = "lm", #Algoritmo
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
View(df)
#Regresiones con intervalos
#0.2 Regresion lineal con intervalos
train.lm <- train(form = Rating ~ Branch + `Customer type` + Gender + `Product line` + `Unit price` + + Quantity + `Unit price`*Quantity + Payment + Month + Day + Frac_Day, #Fórmula
data = train, #Datos
method = "lm", #Algoritmo
trControl = trainControl(method = "cv", number = 5) #Method = cross validation, number=10 (k-fold)
)
test.lm  <- predict(train.lm , newdata=test) #Vector de datos predichos. Recibe una base de datos (newdata) y un modelo entrenado (train.lm)
error.lm <- test$Rating-test.lm #Calcular los errores de predicción (dato real - dato estimado)
summary(train.lm)
print(paste('Error de predicción: ', mean(abs(error.lm))))
